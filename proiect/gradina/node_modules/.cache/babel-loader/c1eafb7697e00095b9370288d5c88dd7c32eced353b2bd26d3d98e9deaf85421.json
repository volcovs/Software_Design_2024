{"ast":null,"code":"import { useCallback, useMemo, useRef } from 'react';\nimport useEventCallback from './useEventCallback';\nimport useMounted from './useMounted';\n/**\n * useFocusManager provides a way to track and manage focus as it moves around\n * a container element. An `onChange` is fired when focus enters or leaves the\n * element, but not when it moves around inside the element, similar to\n * `pointerenter` and `pointerleave` DOM events.\n *\n * ```tsx\n * const [focused, setFocusState] = useState(false)\n *\n * const { onBlur, onFocus } = useFocusManager({\n *   onChange: nextFocused => setFocusState(nextFocused)\n * })\n *\n * return (\n *   <div tabIndex=\"-1\" onFocus={onFocus} onBlur={onBlur}>\n *     {String(focused)}\n *     <input />\n *     <input />\n *\n *     <button>A button</button>\n *   </div>\n * ```\n *\n * @returns a memoized FocusController containing event handlers\n */\nexport default function useFocusManager(opts) {\n  const isMounted = useMounted();\n  const lastFocused = useRef();\n  const handle = useRef();\n  const willHandle = useEventCallback(opts.willHandle);\n  const didHandle = useEventCallback(opts.didHandle);\n  const onChange = useEventCallback(opts.onChange);\n  const isDisabled = useEventCallback(opts.isDisabled);\n  const handleChange = useCallback((focused, event) => {\n    if (focused !== lastFocused.current) {\n      didHandle == null ? void 0 : didHandle(focused, event);\n\n      // only fire a change when unmounted if its a blur\n      if (isMounted() || !focused) {\n        lastFocused.current = focused;\n        onChange == null ? void 0 : onChange(focused, event);\n      }\n    }\n  }, [isMounted, didHandle, onChange, lastFocused]);\n  const handleFocusChange = useCallback((focused, event) => {\n    if (isDisabled()) return;\n    if (event && event.persist) event.persist();\n    if ((willHandle == null ? void 0 : willHandle(focused, event)) === false) {\n      return;\n    }\n    clearTimeout(handle.current);\n    if (focused) {\n      handleChange(focused, event);\n    } else {\n      handle.current = window.setTimeout(() => handleChange(focused, event));\n    }\n  }, [willHandle, handleChange]);\n  return useMemo(() => ({\n    onBlur: event => {\n      handleFocusChange(false, event);\n    },\n    onFocus: event => {\n      handleFocusChange(true, event);\n    }\n  }), [handleFocusChange]);\n}","map":{"version":3,"names":["useCallback","useMemo","useRef","useEventCallback","useMounted","useFocusManager","opts","isMounted","lastFocused","handle","willHandle","didHandle","onChange","isDisabled","handleChange","focused","event","current","handleFocusChange","persist","clearTimeout","window","setTimeout","onBlur","onFocus"],"sources":["D:/Personal_Data/an III/sem_II/PS/proiect/gradina/node_modules/@restart/hooks/esm/useFocusManager.js"],"sourcesContent":["import { useCallback, useMemo, useRef } from 'react';\nimport useEventCallback from './useEventCallback';\nimport useMounted from './useMounted';\n/**\n * useFocusManager provides a way to track and manage focus as it moves around\n * a container element. An `onChange` is fired when focus enters or leaves the\n * element, but not when it moves around inside the element, similar to\n * `pointerenter` and `pointerleave` DOM events.\n *\n * ```tsx\n * const [focused, setFocusState] = useState(false)\n *\n * const { onBlur, onFocus } = useFocusManager({\n *   onChange: nextFocused => setFocusState(nextFocused)\n * })\n *\n * return (\n *   <div tabIndex=\"-1\" onFocus={onFocus} onBlur={onBlur}>\n *     {String(focused)}\n *     <input />\n *     <input />\n *\n *     <button>A button</button>\n *   </div>\n * ```\n *\n * @returns a memoized FocusController containing event handlers\n */\nexport default function useFocusManager(opts) {\n  const isMounted = useMounted();\n  const lastFocused = useRef();\n  const handle = useRef();\n  const willHandle = useEventCallback(opts.willHandle);\n  const didHandle = useEventCallback(opts.didHandle);\n  const onChange = useEventCallback(opts.onChange);\n  const isDisabled = useEventCallback(opts.isDisabled);\n  const handleChange = useCallback((focused, event) => {\n    if (focused !== lastFocused.current) {\n      didHandle == null ? void 0 : didHandle(focused, event);\n\n      // only fire a change when unmounted if its a blur\n      if (isMounted() || !focused) {\n        lastFocused.current = focused;\n        onChange == null ? void 0 : onChange(focused, event);\n      }\n    }\n  }, [isMounted, didHandle, onChange, lastFocused]);\n  const handleFocusChange = useCallback((focused, event) => {\n    if (isDisabled()) return;\n    if (event && event.persist) event.persist();\n    if ((willHandle == null ? void 0 : willHandle(focused, event)) === false) {\n      return;\n    }\n    clearTimeout(handle.current);\n    if (focused) {\n      handleChange(focused, event);\n    } else {\n      handle.current = window.setTimeout(() => handleChange(focused, event));\n    }\n  }, [willHandle, handleChange]);\n  return useMemo(() => ({\n    onBlur: event => {\n      handleFocusChange(false, event);\n    },\n    onFocus: event => {\n      handleFocusChange(true, event);\n    }\n  }), [handleFocusChange]);\n}"],"mappings":"AAAA,SAASA,WAAW,EAAEC,OAAO,EAAEC,MAAM,QAAQ,OAAO;AACpD,OAAOC,gBAAgB,MAAM,oBAAoB;AACjD,OAAOC,UAAU,MAAM,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,eAAeA,CAACC,IAAI,EAAE;EAC5C,MAAMC,SAAS,GAAGH,UAAU,CAAC,CAAC;EAC9B,MAAMI,WAAW,GAAGN,MAAM,CAAC,CAAC;EAC5B,MAAMO,MAAM,GAAGP,MAAM,CAAC,CAAC;EACvB,MAAMQ,UAAU,GAAGP,gBAAgB,CAACG,IAAI,CAACI,UAAU,CAAC;EACpD,MAAMC,SAAS,GAAGR,gBAAgB,CAACG,IAAI,CAACK,SAAS,CAAC;EAClD,MAAMC,QAAQ,GAAGT,gBAAgB,CAACG,IAAI,CAACM,QAAQ,CAAC;EAChD,MAAMC,UAAU,GAAGV,gBAAgB,CAACG,IAAI,CAACO,UAAU,CAAC;EACpD,MAAMC,YAAY,GAAGd,WAAW,CAAC,CAACe,OAAO,EAAEC,KAAK,KAAK;IACnD,IAAID,OAAO,KAAKP,WAAW,CAACS,OAAO,EAAE;MACnCN,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACI,OAAO,EAAEC,KAAK,CAAC;;MAEtD;MACA,IAAIT,SAAS,CAAC,CAAC,IAAI,CAACQ,OAAO,EAAE;QAC3BP,WAAW,CAACS,OAAO,GAAGF,OAAO;QAC7BH,QAAQ,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACG,OAAO,EAAEC,KAAK,CAAC;MACtD;IACF;EACF,CAAC,EAAE,CAACT,SAAS,EAAEI,SAAS,EAAEC,QAAQ,EAAEJ,WAAW,CAAC,CAAC;EACjD,MAAMU,iBAAiB,GAAGlB,WAAW,CAAC,CAACe,OAAO,EAAEC,KAAK,KAAK;IACxD,IAAIH,UAAU,CAAC,CAAC,EAAE;IAClB,IAAIG,KAAK,IAAIA,KAAK,CAACG,OAAO,EAAEH,KAAK,CAACG,OAAO,CAAC,CAAC;IAC3C,IAAI,CAACT,UAAU,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,UAAU,CAACK,OAAO,EAAEC,KAAK,CAAC,MAAM,KAAK,EAAE;MACxE;IACF;IACAI,YAAY,CAACX,MAAM,CAACQ,OAAO,CAAC;IAC5B,IAAIF,OAAO,EAAE;MACXD,YAAY,CAACC,OAAO,EAAEC,KAAK,CAAC;IAC9B,CAAC,MAAM;MACLP,MAAM,CAACQ,OAAO,GAAGI,MAAM,CAACC,UAAU,CAAC,MAAMR,YAAY,CAACC,OAAO,EAAEC,KAAK,CAAC,CAAC;IACxE;EACF,CAAC,EAAE,CAACN,UAAU,EAAEI,YAAY,CAAC,CAAC;EAC9B,OAAOb,OAAO,CAAC,OAAO;IACpBsB,MAAM,EAAEP,KAAK,IAAI;MACfE,iBAAiB,CAAC,KAAK,EAAEF,KAAK,CAAC;IACjC,CAAC;IACDQ,OAAO,EAAER,KAAK,IAAI;MAChBE,iBAAiB,CAAC,IAAI,EAAEF,KAAK,CAAC;IAChC;EACF,CAAC,CAAC,EAAE,CAACE,iBAAiB,CAAC,CAAC;AAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}