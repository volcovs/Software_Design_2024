{"ast":null,"code":"import useCustomEffect from './useCustomEffect';\nimport { dequal } from 'dequal';\nimport useImmediateUpdateEffect from './useImmediateUpdateEffect';\nimport useEventCallback from './useEventCallback';\nimport { useState } from 'react';\nfunction isDepsEqual([nextElement, nextConfig], [prevElement, prevConfig]) {\n  return nextElement === prevElement && dequal(nextConfig, prevConfig);\n}\n\n/**\n * Observe mutations on a DOM node or tree of DOM nodes.\n * Depends on the `MutationObserver` api.\n *\n * ```tsx\n * const [element, attachRef] = useCallbackRef(null);\n *\n * useMutationObserver(element, { subtree: true }, (records) => {\n *\n * });\n *\n * return (\n *   <div ref={attachRef} />\n * )\n * ```\n *\n * @param element The DOM element to observe\n * @param config The observer configuration\n * @param callback A callback fired when a mutation occurs\n */\n\n/**\n * Observe mutations on a DOM node or tree of DOM nodes.\n * use a `MutationObserver` and return records as the are received.\n *\n * ```tsx\n * const [element, attachRef] = useCallbackRef(null);\n *\n * const records = useMutationObserver(element, { subtree: true });\n *\n * return (\n *   <div ref={attachRef} />\n * )\n * ```\n *\n * @param element The DOM element to observe\n * @param config The observer configuration\n */\n\nfunction useMutationObserver(element, config, callback) {\n  const [records, setRecords] = useState(null);\n  const handler = useEventCallback(callback || setRecords);\n  useCustomEffect(() => {\n    if (!element) return;\n\n    // The behavior around reusing mutation observers is confusing\n    // observing again _should_ disable the last listener but doesn't\n    // seem to always be the case, maybe just in JSDOM? In any case the cost\n    // to redeclaring it is gonna be fairly low anyway, so make it simple\n    const observer = new MutationObserver(handler);\n    observer.observe(element, config);\n    return () => {\n      observer.disconnect();\n    };\n  }, [element, config], {\n    isEqual: isDepsEqual,\n    // Intentionally done in render, otherwise observer will miss any\n    // changes made to the DOM during this update\n    effectHook: useImmediateUpdateEffect\n  });\n  return callback ? void 0 : records || [];\n}\nexport default useMutationObserver;","map":{"version":3,"names":["useCustomEffect","dequal","useImmediateUpdateEffect","useEventCallback","useState","isDepsEqual","nextElement","nextConfig","prevElement","prevConfig","useMutationObserver","element","config","callback","records","setRecords","handler","observer","MutationObserver","observe","disconnect","isEqual","effectHook"],"sources":["D:/Personal_Data/an III/sem_II/PS/proiect/gradina/node_modules/@restart/hooks/esm/useMutationObserver.js"],"sourcesContent":["import useCustomEffect from './useCustomEffect';\nimport { dequal } from 'dequal';\nimport useImmediateUpdateEffect from './useImmediateUpdateEffect';\nimport useEventCallback from './useEventCallback';\nimport { useState } from 'react';\nfunction isDepsEqual([nextElement, nextConfig], [prevElement, prevConfig]) {\n  return nextElement === prevElement && dequal(nextConfig, prevConfig);\n}\n\n/**\n * Observe mutations on a DOM node or tree of DOM nodes.\n * Depends on the `MutationObserver` api.\n *\n * ```tsx\n * const [element, attachRef] = useCallbackRef(null);\n *\n * useMutationObserver(element, { subtree: true }, (records) => {\n *\n * });\n *\n * return (\n *   <div ref={attachRef} />\n * )\n * ```\n *\n * @param element The DOM element to observe\n * @param config The observer configuration\n * @param callback A callback fired when a mutation occurs\n */\n\n/**\n * Observe mutations on a DOM node or tree of DOM nodes.\n * use a `MutationObserver` and return records as the are received.\n *\n * ```tsx\n * const [element, attachRef] = useCallbackRef(null);\n *\n * const records = useMutationObserver(element, { subtree: true });\n *\n * return (\n *   <div ref={attachRef} />\n * )\n * ```\n *\n * @param element The DOM element to observe\n * @param config The observer configuration\n */\n\nfunction useMutationObserver(element, config, callback) {\n  const [records, setRecords] = useState(null);\n  const handler = useEventCallback(callback || setRecords);\n  useCustomEffect(() => {\n    if (!element) return;\n\n    // The behavior around reusing mutation observers is confusing\n    // observing again _should_ disable the last listener but doesn't\n    // seem to always be the case, maybe just in JSDOM? In any case the cost\n    // to redeclaring it is gonna be fairly low anyway, so make it simple\n    const observer = new MutationObserver(handler);\n    observer.observe(element, config);\n    return () => {\n      observer.disconnect();\n    };\n  }, [element, config], {\n    isEqual: isDepsEqual,\n    // Intentionally done in render, otherwise observer will miss any\n    // changes made to the DOM during this update\n    effectHook: useImmediateUpdateEffect\n  });\n  return callback ? void 0 : records || [];\n}\nexport default useMutationObserver;"],"mappings":"AAAA,OAAOA,eAAe,MAAM,mBAAmB;AAC/C,SAASC,MAAM,QAAQ,QAAQ;AAC/B,OAAOC,wBAAwB,MAAM,4BAA4B;AACjE,OAAOC,gBAAgB,MAAM,oBAAoB;AACjD,SAASC,QAAQ,QAAQ,OAAO;AAChC,SAASC,WAAWA,CAAC,CAACC,WAAW,EAAEC,UAAU,CAAC,EAAE,CAACC,WAAW,EAAEC,UAAU,CAAC,EAAE;EACzE,OAAOH,WAAW,KAAKE,WAAW,IAAIP,MAAM,CAACM,UAAU,EAAEE,UAAU,CAAC;AACtE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,mBAAmBA,CAACC,OAAO,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EACtD,MAAM,CAACC,OAAO,EAAEC,UAAU,CAAC,GAAGX,QAAQ,CAAC,IAAI,CAAC;EAC5C,MAAMY,OAAO,GAAGb,gBAAgB,CAACU,QAAQ,IAAIE,UAAU,CAAC;EACxDf,eAAe,CAAC,MAAM;IACpB,IAAI,CAACW,OAAO,EAAE;;IAEd;IACA;IACA;IACA;IACA,MAAMM,QAAQ,GAAG,IAAIC,gBAAgB,CAACF,OAAO,CAAC;IAC9CC,QAAQ,CAACE,OAAO,CAACR,OAAO,EAAEC,MAAM,CAAC;IACjC,OAAO,MAAM;MACXK,QAAQ,CAACG,UAAU,CAAC,CAAC;IACvB,CAAC;EACH,CAAC,EAAE,CAACT,OAAO,EAAEC,MAAM,CAAC,EAAE;IACpBS,OAAO,EAAEhB,WAAW;IACpB;IACA;IACAiB,UAAU,EAAEpB;EACd,CAAC,CAAC;EACF,OAAOW,QAAQ,GAAG,KAAK,CAAC,GAAGC,OAAO,IAAI,EAAE;AAC1C;AACA,eAAeJ,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}